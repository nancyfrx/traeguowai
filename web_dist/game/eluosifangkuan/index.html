<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris - 原生 JS</title>
  <style>
    :root{--bg:#0b1020;--panel:#121a33;--text:#e7ecff;--muted:#9fb0de;--b:rgba(255,255,255,.12)}
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;display:grid;place-items:center;background:radial-gradient(900px 500px at 25% 15%,#223b86 0%,var(--bg) 55%,#070a14 100%);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"PingFang SC",sans-serif}
    .wrap{width:min(860px,94vw);display:grid;grid-template-columns:1fr 280px;gap:14px;padding:14px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));border:1px solid var(--b);border-radius:14px;box-shadow:0 18px 60px rgba(0,0,0,.35);overflow:hidden}
    .stage{position:relative;display:grid;place-items:center;padding:14px}
    canvas{image-rendering:pixelated;background:linear-gradient(180deg,#070b18,#0a0f22);border:1px solid rgba(255,255,255,.14);border-radius:12px}
    .side{padding:12px;display:flex;flex-direction:column;gap:10px}
    .h{display:flex;align-items:baseline;justify-content:space-between;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.08)}
    .h b{font-size:16px}
    .h span{font-size:12px;color:var(--muted)}
    .stats{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .stat{padding:10px 12px;border:1px solid rgba(255,255,255,.10);border-radius:12px;background:rgba(0,0,0,.14)}
    .stat .k{font-size:12px;color:var(--muted)}
    .stat .v{font-weight:800;font-variant-numeric:tabular-nums;font-size:18px;margin-top:4px}
    .btns{display:flex;gap:10px;flex-wrap:wrap}
    button{cursor:pointer;border:1px solid rgba(255,255,255,.18);background:rgba(255,255,255,.06);color:var(--text);padding:9px 10px;border-radius:12px;font-weight:700}
    button:hover{background:rgba(255,255,255,.10)}
    .help{font-size:12px;color:var(--muted);line-height:1.6;border:1px dashed rgba(255,255,255,.18);border-radius:12px;padding:10px;background:rgba(0,0,0,.12)}
    .overlay{position:absolute;inset:14px;display:none;place-items:center;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.14);border-radius:12px;backdrop-filter:blur(3px)}
    .overlay.show{display:grid}
    .overlay .box{max-width:420px;padding:12px 14px;border-radius:12px;background:rgba(10,15,34,.75);border:1px solid rgba(255,255,255,.14);text-align:center}
    .overlay h2{margin:0 0 6px;font-size:18px}
    .overlay p{margin:0;color:var(--muted);font-size:12px;line-height:1.6}
    @media (max-width:840px){.wrap{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card stage">
      <canvas id="c" width="360" height="720"></canvas>
      <div id="ov" class="overlay"><div class="box"><h2 id="ovt">暂停</h2><p id="ovp">按 <b>P</b> 继续</p></div></div>
    </div>
    <aside class="card side">
      <div class="h"><b>俄罗斯方块</b><span>原生 JS</span></div>
      <div class="stats">
        <div class="stat"><div class="k">分数</div><div class="v" id="score">0</div></div>
        <div class="stat"><div class="k">等级</div><div class="v" id="level">1</div></div>
        <div class="stat"><div class="k">消行</div><div class="v" id="lines">0</div></div>
        <div class="stat"><div class="k">速度</div><div class="v" id="speed">1.0x</div></div>
      </div>
      <div class="btns">
        <button id="start">开始/重开</button>
        <button id="pause">暂停/继续</button>
      </div>
      <div class="help">
        <div><b>键位</b></div>
        <div>- ←/→：移动</div>
        <div>- ↓：软降</div>
        <div>- 空格：硬降</div>
        <div>- Z / X / ↑：旋转</div>
        <div>- C：Hold（暂存）</div>
        <div>- P：暂停</div>
      </div>
    </aside>
  </div>

<script>
(() => {
  'use strict';

  const COLS=10, ROWS=20, SIZE=36;
  const COLORS={I:'#60a5fa',O:'#facc15',T:'#a78bfa',S:'#34d399',Z:'#fb7185',J:'#38bdf8',L:'#fb923c',G:'rgba(255,255,255,.18)',GRID:'rgba(255,255,255,.06)'};
  const SHAPES={
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    O:[[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    T:[[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    S:[[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],
    Z:[[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],
    J:[[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
    L:[[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],
  };
  const LINE_SCORE=[0,100,300,500,800];

  const c=document.getElementById('c');
  const ctx=c.getContext('2d');
  const scoreEl=document.getElementById('score');
  const levelEl=document.getElementById('level');
  const linesEl=document.getElementById('lines');
  const speedEl=document.getElementById('speed');
  const ov=document.getElementById('ov');
  const ovt=document.getElementById('ovt');
  const ovp=document.getElementById('ovp');

  const st={
    grid:[], bag:[], queue:[],
    piece:null, hold:null, holdUsed:false,
    running:false, paused:false, over:false,
    score:0, lines:0, level:1,
    dropT:0, dropI:900,
    // simple input repeat
    keys:new Set(), leftT:0, rightT:0, das:120, arr:30,
  };

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const copy=m=>m.map(r=>r.slice());
  const rotCW=m=>{const N=m.length;const o=Array.from({length:N},()=>Array(N).fill(0));for(let y=0;y<N;y++)for(let x=0;x<N;x++)o[x][N-1-y]=m[y][x];return o;};
  const rotCCW=m=>{const N=m.length;const o=Array.from({length:N},()=>Array(N).fill(0));for(let y=0;y<N;y++)for(let x=0;x<N;x++)o[N-1-x][y]=m[y][x];return o;};
  function makeBag(){
    const a=Object.keys(SHAPES);
    for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]];}
    return a;
  }
  function resetGrid(){ st.grid=Array.from({length:ROWS},()=>Array(COLS).fill(null)); }
  function dropInterval(level){ const v=900*Math.pow(0.86,level-1); return clamp(v,90,900); }
  function ui(){
    scoreEl.textContent=String(st.score);
    linesEl.textContent=String(st.lines);
    levelEl.textContent=String(st.level);
    speedEl.textContent=(900/st.dropI).toFixed(1)+'x';
  }
  function overlay(show,title,html){
    if(show){ ov.classList.add('show'); ovt.textContent=title||'暂停'; ovp.innerHTML=html||'按 <b>P</b> 继续'; }
    else ov.classList.remove('show');
  }
  function ensureQueue(){
    while(st.queue.length<5){ if(st.bag.length===0) st.bag=makeBag(); st.queue.push(st.bag.pop()); }
  }
  function collides(p,dx,dy,mat){
    const m=mat||p.mat, px=p.x+dx, py=p.y+dy;
    for(let y=0;y<4;y++)for(let x=0;x<4;x++) if(m[y][x]){
      const gx=px+x, gy=py+y;
      if(gx<0||gx>=COLS) return true;
      if(gy>=ROWS) return true;
      if(gy<0) continue;
      if(st.grid[gy][gx]) return true;
    }
    return false;
  }
  function spawn(){
    ensureQueue();
    const type=st.queue.shift();
    ensureQueue();
    st.piece={type, mat:copy(SHAPES[type]), x:3, y:-1};
    st.holdUsed=false;
    if(collides(st.piece,0,0,st.piece.mat)){
      st.over=true; st.running=false;
      overlay(true,'游戏结束','按 <b>开始/重开</b> 重新开始');
    }
  }
  function clearLines(){
    let cleared=0;
    for(let y=ROWS-1;y>=0;y--){
      if(st.grid[y].every(v=>v!==null)){
        st.grid.splice(y,1);
        st.grid.unshift(Array(COLS).fill(null));
        cleared++; y++;
      }
    }
    return cleared;
  }
  function lock(){
    const p=st.piece;
    for(let y=0;y<4;y++)for(let x=0;x<4;x++) if(p.mat[y][x]){
      const gx=p.x+x, gy=p.y+y;
      if(gy<0) continue;
      st.grid[gy][gx]=p.type;
    }
    const n=clearLines();
    if(n>0){
      st.score += LINE_SCORE[n]*st.level;
      st.lines += n;
      const nl=1+Math.floor(st.lines/10);
      if(nl!==st.level){ st.level=nl; st.dropI=dropInterval(st.level); }
    }
    ui();
    spawn();
  }
  function move(dx,dy){
    const p=st.piece; if(!p) return false;
    if(!collides(p,dx,dy,p.mat)){ p.x+=dx; p.y+=dy; return true; }
    return false;
  }
  function hardDrop(){
    if(!st.piece) return;
    let d=0; while(move(0,1)) d++;
    if(d>0) st.score += d*2;
    ui();
    lock();
  }
  function rotate(dir){
    const p=st.piece; if(!p) return;
    const r=dir>0?rotCW(p.mat):rotCCW(p.mat);
    const kicks=[0,-1,1,-2,2];
    for(const k of kicks){ if(!collides(p,k,0,r)){ p.mat=r; p.x+=k; return; } }
  }
  function hold(){
    if(st.holdUsed || !st.piece) return;
    const cur=st.piece.type;
    if(st.hold===null){ st.hold=cur; spawn(); }
    else {
      const tmp=st.hold; st.hold=cur;
      st.piece={type:tmp, mat:copy(SHAPES[tmp]), x:3, y:-1};
      if(collides(st.piece,0,0,st.piece.mat)){
        st.over=true; st.running=false;
        overlay(true,'游戏结束','按 <b>开始/重开</b> 重新开始');
      }
    }
    st.holdUsed=true;
  }
  function ghostY(){
    const p=st.piece; if(!p) return 0;
    let y=p.y;
    while(!collides(p,0,(y-p.y)+1,p.mat)) y++;
    return y;
  }

  // rendering
  function rrect(c2,x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    c2.beginPath();
    c2.moveTo(x+rr,y);
    c2.arcTo(x+w,y,x+w,y+h,rr);
    c2.arcTo(x+w,y+h,x,y+h,rr);
    c2.arcTo(x,y+h,x,y,rr);
    c2.arcTo(x,y,x+w,y,rr);
    c2.closePath();
  }
  function cell(color,x,y,a=1){
    const px=x*SIZE, py=y*SIZE;
    ctx.save();
    ctx.globalAlpha=a;
    ctx.fillStyle=color;
    rrect(ctx,px+1,py+1,SIZE-2,SIZE-2,7);
    ctx.fill();
    ctx.globalAlpha=a*0.35;
    ctx.fillStyle='#fff';
    rrect(ctx,px+3,py+3,SIZE-6,(SIZE-6)*0.35,7);
    ctx.fill();
    ctx.restore();
  }
  function draw(){
    ctx.clearRect(0,0,c.width,c.height);
    // grid lines
    ctx.save();
    ctx.strokeStyle=COLORS.GRID; ctx.lineWidth=1;
    for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(x*SIZE+0.5,0); ctx.lineTo(x*SIZE+0.5,ROWS*SIZE); ctx.stroke(); }
    for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*SIZE+0.5); ctx.lineTo(COLS*SIZE,y*SIZE+0.5); ctx.stroke(); }
    ctx.restore();

    // settled
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(st.grid[y][x]) cell(COLORS[st.grid[y][x]],x,y,1);

    // ghost
    if(st.piece && st.running && !st.paused){
      const p=st.piece, gy=ghostY();
      for(let y=0;y<4;y++)for(let x=0;x<4;x++) if(p.mat[y][x]){
        const gx=p.x+x, yy=gy+y; if(yy<0) continue;
        cell(COLORS.G,gx,yy,1);
      }
    }
    // active
    if(st.piece){
      const p=st.piece;
      for(let y=0;y<4;y++)for(let x=0;x<4;x++) if(p.mat[y][x]){
        const gx=p.x+x, gy=p.y+y; if(gy<0) continue;
        cell(COLORS[p.type],gx,gy,1);
      }
    }

    // top shade
    ctx.save();
    const g=ctx.createLinearGradient(0,0,0,70);
    g.addColorStop(0,'rgba(0,0,0,.35)'); g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g; ctx.fillRect(0,0,COLS*SIZE,70);
    ctx.restore();

    // hold/next text
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,.12)';
    ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText('Hold: '+(st.hold||'-'), 10, 18);
    ctx.fillText('Next: '+(st.queue[0]||'-'), 110, 18);
    ctx.restore();
  }

  // loop
  let last=0;
  function tick(ts){
    const dt=Math.min((ts-last)/1000, 0.033); last=ts;

    if(st.running && !st.paused && !st.over){
      st.dropT += dt*1000;
      const soft = st.keys.has('ArrowDown') || st.keys.has('KeyS');
      const interval = soft ? Math.max(35, st.dropI*0.12) : st.dropI;
      if(st.dropT >= interval){
        st.dropT = 0;
        if(!move(0,1)) lock();
      }

      // left/right with simple DAS/ARR
      const left = st.keys.has('ArrowLeft') || st.keys.has('KeyA');
      const right = st.keys.has('ArrowRight') || st.keys.has('KeyD');

      if(left && !right){
        st.leftT += dt*1000;
        if(st.leftT===dt*1000) move(-1,0);
        else if(st.leftT > st.das){
          const t = st.leftT - st.das;
          if(Math.floor(t/st.arr) !== Math.floor((t-dt*1000)/st.arr)) move(-1,0);
        }
      } else st.leftT = 0;

      if(right && !left){
        st.rightT += dt*1000;
        if(st.rightT===dt*1000) move(1,0);
        else if(st.rightT > st.das){
          const t = st.rightT - st.das;
          if(Math.floor(t/st.arr) !== Math.floor((t-dt*1000)/st.arr)) move(1,0);
        }
      } else st.rightT = 0;
    }

    draw();
    requestAnimationFrame(tick);
  }

  // controls
  function startGame(){
    st.running=true; st.paused=false; st.over=false;
    st.score=0; st.lines=0; st.level=1;
    st.dropI=dropInterval(st.level); st.dropT=0;
    st.hold=null; st.holdUsed=false;
    st.bag=[]; st.queue=[];
    resetGrid();
    ensureQueue();
    spawn();
    ui();
    overlay(false);
  }
  function togglePause(){
    if(!st.running || st.over) return;
    st.paused=!st.paused;
    overlay(st.paused,'暂停','按 <b>P</b> 继续');
  }

  window.addEventListener('keydown', (e)=>{
    // prevent scroll on arrows/space
    if(['ArrowLeft','ArrowRight','ArrowDown','ArrowUp','Space'].includes(e.code)) e.preventDefault();

    // global
    if(e.code==='KeyP'){ togglePause(); return; }
    if(e.code==='Enter'){ startGame(); return; }

    if(!st.running || st.paused || st.over) {
      if(e.code==='Space' && !st.running) startGame();
      return;
    }

    // one-shot actions
    if(e.repeat) { st.keys.add(e.code); return; }
    st.keys.add(e.code);

    if(e.code==='Space') hardDrop();
    else if(e.code==='KeyZ') rotate(-1);
    else if(e.code==='KeyX' || e.code==='ArrowUp') rotate(1);
    else if(e.code==='KeyC') hold();
  }, {passive:false});

  window.addEventListener('keyup', (e)=>{ st.keys.delete(e.code); }, {passive:true});

  document.getElementById('start').addEventListener('click', startGame);
  document.getElementById('pause').addEventListener('click', togglePause);

  // init
  resetGrid(); ui();
  overlay(true,'准备开始','按 <b>空格</b> 或点击 <b>开始/重开</b>');
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
